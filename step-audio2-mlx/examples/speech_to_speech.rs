//! Speech-to-Speech Pipeline Test
//!
//! Full end-to-end test: Audio input → Encoder → LLM → Audio tokens → TTS → Audio output
//!
//! Usage:
//!     cargo run --release --features tts --example speech_to_speech -- <input.wav>

use std::env;
use std::path::PathBuf;
use std::time::Instant;

use step_audio2_mlx::audio::load_wav;
use step_audio2_mlx::{StepAudio2, Result, Error};

fn main() -> Result<()> {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("Step-Audio 2 Speech-to-Speech Pipeline");
        eprintln!();
        eprintln!("Usage: {} <input.wav>", args[0]);
        eprintln!();
        eprintln!("This runs the full pipeline:");
        eprintln!("  Audio → Encoder → LLM → Audio Tokens → Flow Decoder → HiFi-GAN → Audio");
        return Err(Error::Config("Missing audio file argument".into()));
    }

    let input_path = PathBuf::from(&args[1]);

    // Find model directory
    let model_dirs = [
        "./Step-Audio-2-mini",
        "../Step-Audio-2-mini",
        "step-audio2-mlx/Step-Audio-2-mini",
    ];

    let model_dir = model_dirs.iter()
        .map(PathBuf::from)
        .find(|p| p.exists())
        .ok_or_else(|| Error::Config("Step-Audio-2-mini model not found".into()))?;

    println!("╔══════════════════════════════════════════════════════════════════════╗");
    println!("║          STEP-AUDIO 2 SPEECH-TO-SPEECH TEST                         ║");
    println!("╚══════════════════════════════════════════════════════════════════════╝");
    println!();

    // Load input audio
    println!("Loading input audio: {}", input_path.display());
    let (samples, sample_rate) = load_wav(&input_path)?;
    let audio_duration = samples.len() as f64 / sample_rate as f64;
    println!("  Duration: {:.2}s at {}Hz ({} samples)", audio_duration, sample_rate, samples.len());
    println!();

    // Load model
    println!("Loading model from {}...", model_dir.display());
    let load_start = Instant::now();
    let mut model = StepAudio2::load(&model_dir)?;
    let load_time = load_start.elapsed().as_secs_f64();
    println!("  Model loaded in {:.2}s", load_time);
    println!();

    // Warmup
    println!("Warming up model...");
    let _ = model.warmup()?;
    println!();

    // Speech-to-Speech
    println!("Running speech-to-speech pipeline...");
    let s2s_start = Instant::now();
    let (text, audio) = model.speech_to_speech(&input_path)?;
    let s2s_time = s2s_start.elapsed().as_secs_f64();

    println!();
    println!("╔══════════════════════════════════════════════════════════════════════╗");
    println!("║                          RESULTS                                    ║");
    println!("╚══════════════════════════════════════════════════════════════════════╝");
    println!();
    println!("Text output: {}", text);
    println!();

    if audio.is_empty() {
        println!("No audio tokens were generated by the LLM.");
        println!("The model may have responded with text only.");
        println!();
        println!("This is expected behavior for Step-Audio 2 mini,");
        println!("which is primarily an ASR/understanding model.");
    } else {
        let output_duration = audio.len() as f32 / 24000.0;
        let audio_rms = (audio.iter().map(|x| x * x).sum::<f32>() / audio.len() as f32).sqrt();
        println!("Audio output: {} samples ({:.2}s @ 24kHz)", audio.len(), output_duration);
        println!("Audio RMS: {:.6}", audio_rms);

        let output_path = PathBuf::from("./s2s_output.wav");
        model.save_audio(&audio, &output_path)?;
        println!("Saved to: {}", output_path.display());
    }

    println!();
    println!("╔══════════════════════════════════════════════════════════════════════╗");
    println!("║                        PERFORMANCE                                  ║");
    println!("╠══════════════════════════════════════════════════════════════════════╣");
    println!("║ Input duration:    {:.2}s", audio_duration);
    println!("║ Pipeline time:     {:.2}s", s2s_time);
    println!("║ Real-time factor:  {:.2}x", s2s_time / audio_duration);
    println!("╚══════════════════════════════════════════════════════════════════════╝");

    Ok(())
}
